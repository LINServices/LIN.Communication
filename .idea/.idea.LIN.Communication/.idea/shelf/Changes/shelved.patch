Index: .gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>## Ignore Visual Studio temporary files, build results, and\r\n## files generated by popular Visual Studio add-ons.\r\n##\r\n## Get latest from https://github.com/github/gitignore/blob/main/VisualStudio.gitignore\r\n\r\n\r\n./LIN.Communication/appsettings.json\r\nLIN.Communication/appsettings.json\r\n\r\n./LIN.Communication/appsettings.Development.json\r\nLIN.Communication/appsettings.Development.json\r\n\r\n\r\n# User-specific files\r\n*.rsuser\r\n*.suo\r\n*.user\r\n*.userosscache\r\n*.sln.docstates\r\n\r\n# User-specific files (MonoDevelop/Xamarin Studio)\r\n*.userprefs\r\n\r\n# Mono auto generated files\r\nmono_crash.*\r\n\r\n# Build results\r\n[Dd]ebug/\r\n[Dd]ebugPublic/\r\n[Rr]elease/\r\n[Rr]eleases/\r\nx64/\r\nx86/\r\n[Ww][Ii][Nn]32/\r\n[Aa][Rr][Mm]/\r\n[Aa][Rr][Mm]64/\r\nbld/\r\n[Bb]in/\r\n[Oo]bj/\r\n[Ll]og/\r\n[Ll]ogs/\r\n\r\n# Visual Studio 2015/2017 cache/options directory\r\n.vs/\r\n# Uncomment if you have tasks that create the project's static files in wwwroot\r\n#wwwroot/\r\n\r\n# Visual Studio 2017 auto generated files\r\nGenerated\\ Files/\r\n\r\n# MSTest test Results\r\n[Tt]est[Rr]esult*/\r\n[Bb]uild[Ll]og.*\r\n\r\n# NUnit\r\n*.VisualState.xml\r\nTestResult.xml\r\nnunit-*.xml\r\n\r\n# Build Results of an ATL Project\r\n[Dd]ebugPS/\r\n[Rr]eleasePS/\r\ndlldata.c\r\n\r\n# Benchmark Results\r\nBenchmarkDotNet.Artifacts/\r\n\r\n# .NET Core\r\nproject.lock.json\r\nproject.fragment.lock.json\r\nartifacts/\r\n\r\n# ASP.NET Scaffolding\r\nScaffoldingReadMe.txt\r\n\r\n# StyleCop\r\nStyleCopReport.xml\r\n\r\n# Files built by Visual Studio\r\n*_i.c\r\n*_p.c\r\n*_h.h\r\n*.ilk\r\n*.meta\r\n*.obj\r\n*.iobj\r\n*.pch\r\n*.pdb\r\n*.ipdb\r\n*.pgc\r\n*.pgd\r\n*.rsp\r\n*.sbr\r\n*.tlb\r\n*.tli\r\n*.tlh\r\n*.tmp\r\n*.tmp_proj\r\n*_wpftmp.csproj\r\n*.log\r\n*.tlog\r\n*.vspscc\r\n*.vssscc\r\n.builds\r\n*.pidb\r\n*.svclog\r\n*.scc\r\n\r\n# Chutzpah Test files\r\n_Chutzpah*\r\n\r\n# Visual C++ cache files\r\nipch/\r\n*.aps\r\n*.ncb\r\n*.opendb\r\n*.opensdf\r\n*.sdf\r\n*.cachefile\r\n*.VC.db\r\n*.VC.VC.opendb\r\n\r\n# Visual Studio profiler\r\n*.psess\r\n*.vsp\r\n*.vspx\r\n*.sap\r\n\r\n# Visual Studio Trace Files\r\n*.e2e\r\n\r\n# TFS 2012 Local Workspace\r\n$tf/\r\n\r\n# Guidance Automation Toolkit\r\n*.gpState\r\n\r\n# ReSharper is a .NET coding add-in\r\n_ReSharper*/\r\n*.[Rr]e[Ss]harper\r\n*.DotSettings.user\r\n\r\n# TeamCity is a build add-in\r\n_TeamCity*\r\n\r\n# DotCover is a Code Coverage Tool\r\n*.dotCover\r\n\r\n# AxoCover is a Code Coverage Tool\r\n.axoCover/*\r\n!.axoCover/settings.json\r\n\r\n# Coverlet is a free, cross platform Code Coverage Tool\r\ncoverage*.json\r\ncoverage*.xml\r\ncoverage*.info\r\n\r\n# Visual Studio code coverage results\r\n*.coverage\r\n*.coveragexml\r\n\r\n# NCrunch\r\n_NCrunch_*\r\n.*crunch*.local.xml\r\nnCrunchTemp_*\r\n\r\n# MightyMoose\r\n*.mm.*\r\nAutoTest.Net/\r\n\r\n# Web workbench (sass)\r\n.sass-cache/\r\n\r\n# Installshield output folder\r\n[Ee]xpress/\r\n\r\n# DocProject is a documentation generator add-in\r\nDocProject/buildhelp/\r\nDocProject/Help/*.HxT\r\nDocProject/Help/*.HxC\r\nDocProject/Help/*.hhc\r\nDocProject/Help/*.hhk\r\nDocProject/Help/*.hhp\r\nDocProject/Help/Html2\r\nDocProject/Help/html\r\n\r\n# Click-Once directory\r\npublish/\r\n\r\n# Publish Web Output\r\n*.[Pp]ublish.xml\r\n*.azurePubxml\r\n# Note: Comment the next line if you want to checkin your web deploy settings,\r\n# but database connection strings (with potential passwords) will be unencrypted\r\n*.pubxml\r\n*.publishproj\r\n\r\n# Microsoft Azure Web App publish settings. Comment the next line if you want to\r\n# checkin your Azure Web App publish settings, but sensitive information contained\r\n# in these scripts will be unencrypted\r\nPublishScripts/\r\n\r\n# NuGet Packages\r\n*.nupkg\r\n# NuGet Symbol Packages\r\n*.snupkg\r\n# The packages folder can be ignored because of Package Restore\r\n**/[Pp]ackages/*\r\n# except build/, which is used as an MSBuild target.\r\n!**/[Pp]ackages/build/\r\n# Uncomment if necessary however generally it will be regenerated when needed\r\n#!**/[Pp]ackages/repositories.config\r\n# NuGet v3's project.json files produces more ignorable files\r\n*.nuget.props\r\n*.nuget.targets\r\n\r\n# Microsoft Azure Build Output\r\ncsx/\r\n*.build.csdef\r\n\r\n# Microsoft Azure Emulator\r\necf/\r\nrcf/\r\n\r\n# Windows Store app package directories and files\r\nAppPackages/\r\nBundleArtifacts/\r\nPackage.StoreAssociation.xml\r\n_pkginfo.txt\r\n*.appx\r\n*.appxbundle\r\n*.appxupload\r\n\r\n# Visual Studio cache files\r\n# files ending in .cache can be ignored\r\n*.[Cc]ache\r\n# but keep track of directories ending in .cache\r\n!?*.[Cc]ache/\r\n\r\n# Others\r\nClientBin/\r\n~$*\r\n*~\r\n*.dbmdl\r\n*.dbproj.schemaview\r\n*.jfm\r\n*.pfx\r\n*.publishsettings\r\norleans.codegen.cs\r\n\r\n# Including strong name files can present a security risk\r\n# (https://github.com/github/gitignore/pull/2483#issue-259490424)\r\n#*.snk\r\n\r\n# Since there are multiple workflows, uncomment next line to ignore bower_components\r\n# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)\r\n#bower_components/\r\n\r\n# RIA/Silverlight projects\r\nGenerated_Code/\r\n\r\n# Backup & report files from converting an old project file\r\n# to a newer Visual Studio version. Backup files are not needed,\r\n# because we have git ;-)\r\n_UpgradeReport_Files/\r\nBackup*/\r\nUpgradeLog*.XML\r\nUpgradeLog*.htm\r\nServiceFabricBackup/\r\n*.rptproj.bak\r\n\r\n# SQL Server files\r\n*.mdf\r\n*.ldf\r\n*.ndf\r\n\r\n# Business Intelligence projects\r\n*.rdl.data\r\n*.bim.layout\r\n*.bim_*.settings\r\n*.rptproj.rsuser\r\n*- [Bb]ackup.rdl\r\n*- [Bb]ackup ([0-9]).rdl\r\n*- [Bb]ackup ([0-9][0-9]).rdl\r\n\r\n# Microsoft Fakes\r\nFakesAssemblies/\r\n\r\n# GhostDoc plugin setting file\r\n*.GhostDoc.xml\r\n\r\n# Node.js Tools for Visual Studio\r\n.ntvs_analysis.dat\r\nnode_modules/\r\n\r\n# Visual Studio 6 build log\r\n*.plg\r\n\r\n# Visual Studio 6 workspace options file\r\n*.opt\r\n\r\n# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)\r\n*.vbw\r\n\r\n# Visual Studio 6 auto-generated project file (contains which files were open etc.)\r\n*.vbp\r\n\r\n# Visual Studio 6 workspace and project file (working project files containing files to include in project)\r\n*.dsw\r\n*.dsp\r\n\r\n# Visual Studio 6 technical files\r\n*.ncb\r\n*.aps\r\n\r\n# Visual Studio LightSwitch build output\r\n**/*.HTMLClient/GeneratedArtifacts\r\n**/*.DesktopClient/GeneratedArtifacts\r\n**/*.DesktopClient/ModelManifest.xml\r\n**/*.Server/GeneratedArtifacts\r\n**/*.Server/ModelManifest.xml\r\n_Pvt_Extensions\r\n\r\n# Paket dependency manager\r\n.paket/paket.exe\r\npaket-files/\r\n\r\n# FAKE - F# Make\r\n.fake/\r\n\r\n# CodeRush personal settings\r\n.cr/personal\r\n\r\n# Python Tools for Visual Studio (PTVS)\r\n__pycache__/\r\n*.pyc\r\n\r\n# Cake - Uncomment if you are using it\r\n# tools/**\r\n# !tools/packages.config\r\n\r\n# Tabs Studio\r\n*.tss\r\n\r\n# Telerik's JustMock configuration file\r\n*.jmconfig\r\n\r\n# BizTalk build output\r\n*.btp.cs\r\n*.btm.cs\r\n*.odx.cs\r\n*.xsd.cs\r\n\r\n# OpenCover UI analysis results\r\nOpenCover/\r\n\r\n# Azure Stream Analytics local run output\r\nASALocalRun/\r\n\r\n# MSBuild Binary and Structured Log\r\n*.binlog\r\n\r\n# NVidia Nsight GPU debugger configuration file\r\n*.nvuser\r\n\r\n# MFractors (Xamarin productivity tool) working folder\r\n.mfractor/\r\n\r\n# Local History for Visual Studio\r\n.localhistory/\r\n\r\n# Visual Studio History (VSHistory) files\r\n.vshistory/\r\n\r\n# BeatPulse healthcheck temp database\r\nhealthchecksdb\r\n\r\n# Backup folder for Package Reference Convert tool in Visual Studio 2017\r\nMigrationBackup/\r\n\r\n# Ionide (cross platform F# VS Code tools) working folder\r\n.ionide/\r\n\r\n# Fody - auto-generated XML schema\r\nFodyWeavers.xsd\r\n\r\n# VS Code files for those working on multiple tools\r\n.vscode/*\r\n!.vscode/settings.json\r\n!.vscode/tasks.json\r\n!.vscode/launch.json\r\n!.vscode/extensions.json\r\n*.code-workspace\r\n\r\n# Local History for Visual Studio Code\r\n.history/\r\n\r\n# Windows Installer files from build outputs\r\n*.cab\r\n*.msi\r\n*.msix\r\n*.msm\r\n*.msp\r\n\r\n# JetBrains Rider\r\n*.sln.iml
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.gitignore b/.gitignore
--- a/.gitignore	(revision 4862f6d6b8acc1ddc3f69c239cd7d7c2f3bd0bcf)
+++ b/.gitignore	(date 1695908980059)
@@ -42,6 +42,7 @@
 
 # Visual Studio 2015/2017 cache/options directory
 .vs/
+.idea/
 # Uncomment if you have tasks that create the project's static files in wwwroot
 #wwwroot/
 
Index: LIN.Communication/Controllers/MembersController.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>namespace LIN.Communication.Controllers;\r\n\r\n\r\n[Route(\"conversations\")]\r\npublic class MembersController : ControllerBase\r\n{\r\n\r\n\r\n    /// <summary>\r\n    /// Un usuario esta online\r\n    /// </summary>\r\n    /// <param name=\"id\">ID del usuario</param>\r\n    [HttpGet(\"isOnline\")]\r\n    public HttpReadOneResponse<IsOnlineResult> ReadOnline([FromQuery] int id)\r\n    {\r\n\r\n        // Obtiene el perfil\r\n        var profile = Hubs.ChatHub.Profiles.Where(T => T.Key == id).FirstOrDefault().Value;\r\n\r\n        return new ReadOneResponse<IsOnlineResult>()\r\n        {\r\n            Response = Responses.Success,\r\n            Model =  new()\r\n            {\r\n                ID = id,\r\n                IsOnline = profile?.Devices.Any() ?? false,\r\n                LastTime = profile?.LastTime ?? new(),\r\n            } \r\n        };\r\n\r\n    }\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Obtiene los miembros de una conversaci√≥n\r\n    /// </summary>\r\n    /// <param name=\"id\">ID de la conversaci√≥n.</param>\r\n    /// <param name=\"token\">Token de acceso.</param>\r\n    [HttpGet(\"{id}/members\")]\r\n    public async Task<HttpReadAllResponse<MemberChatModel>> ReadAll([FromRoute] int id, [FromHeader] string token)\r\n    {\r\n\r\n        // Obtiene la info del token\r\n        var (isValid, profileID, _, _) = Jwt.Validate(token);\r\n\r\n        // Token es invalido\r\n        if (!isValid)\r\n            return new ReadAllResponse<MemberChatModel>()\r\n            {\r\n                Message = \"El token es invalido.\",\r\n                Response = Responses.Unauthorized\r\n            };\r\n\r\n        // Busca el acceso\r\n        var have = await Data.Conversations.HaveAccessFor(profileID, id);\r\n\r\n        // Si no tiene acceso\r\n        if (have.Response != Responses.Success)\r\n            return new ReadAllResponse<MemberChatModel>\r\n            {\r\n                Response = Responses.Unauthorized,\r\n                Message = \"No tienes acceso a esta conversaci√≥n.\"\r\n            };\r\n\r\n        // Obtiene el usuario\r\n        var result = await Data.Conversations.ReadMembers(id);\r\n\r\n        // Retorna el resultado\r\n        return result ?? new();\r\n\r\n    }\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Obtiene los miembros de una conversaci√≥n con info del usuario.\r\n    /// </summary>\r\n    /// <param name=\"id\">ID de la conversaci√≥n.</param>\r\n    /// <param name=\"token\">Token de acceso.</param>\r\n    [HttpGet(\"{id}/members/info\")]\r\n    public async Task<HttpReadAllResponse<SessionModel<MemberChatModel>>> ReadAllInfo([FromRoute] int id, [FromHeader] string token)\r\n    {\r\n\r\n        // Obtiene el usuario\r\n        var result = await Data.Conversations.ReadMembers(id);\r\n\r\n        var x = result.Models.Select(T => T.Profile.AccountID).ToList();\r\n\r\n        var resultAccounts = await LIN.Access.Auth.Controllers.Account.Read(x, token);\r\n\r\n\r\n        var re = (from P in result.Models\r\n                  join A in resultAccounts.Models\r\n                  on P.Profile.AccountID equals A.ID\r\n                  select new SessionModel<MemberChatModel>\r\n                  {\r\n                      Account = A,\r\n                      Profile = new()\r\n                      {\r\n                          Rol = P.Rol,\r\n                          Profile = new()\r\n                          {\r\n                              ID = P.Profile.ID,\r\n                              Alias = P.Profile.Alias\r\n                          }\r\n\r\n                      }\r\n                  }).ToList();\r\n\r\n\r\n        // Retorna el resultado\r\n        return new ReadAllResponse<SessionModel<MemberChatModel>>\r\n        {\r\n            Models = re,\r\n            Response = Responses.Success\r\n        };\r\n\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LIN.Communication/Controllers/MembersController.cs b/LIN.Communication/Controllers/MembersController.cs
--- a/LIN.Communication/Controllers/MembersController.cs	(revision 4862f6d6b8acc1ddc3f69c239cd7d7c2f3bd0bcf)
+++ b/LIN.Communication/Controllers/MembersController.cs	(date 1695908804699)
@@ -11,7 +11,7 @@
     /// </summary>
     /// <param name="id">ID del usuario</param>
     [HttpGet("isOnline")]
-    public HttpReadOneResponse<IsOnlineResult> ReadOnline([FromQuery] int id)
+    public async Task<HttpReadOneResponse<IsOnlineResult>> ReadOnline([FromQuery] int id)
     {
 
         // Obtiene el perfil
@@ -24,11 +24,15 @@
             {
                 ID = id,
                 IsOnline = profile?.Devices.Any() ?? false,
-                LastTime = profile?.LastTime ?? new(),
+                LastTime = profile?.LastTime ?? (await Data.Profiles.GetLastConnection(id)).Model,
             } 
         };
 
     }
+    
+    
+    
+    
 
 
 
Index: .idea/.idea.LIN.Communication/.idea/indexLayout.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.LIN.Communication/.idea/indexLayout.xml b/.idea/.idea.LIN.Communication/.idea/indexLayout.xml
new file mode 100644
--- /dev/null	(date 1695907640212)
+++ b/.idea/.idea.LIN.Communication/.idea/indexLayout.xml	(date 1695907640212)
@@ -0,0 +1,8 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="UserContentModel">
+    <attachedFolders />
+    <explicitIncludes />
+    <explicitExcludes />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/.idea.LIN.Communication/.idea/vcs.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.LIN.Communication/.idea/vcs.xml b/.idea/.idea.LIN.Communication/.idea/vcs.xml
new file mode 100644
--- /dev/null	(date 1695907640224)
+++ b/.idea/.idea.LIN.Communication/.idea/vcs.xml	(date 1695907640224)
@@ -0,0 +1,6 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="VcsDirectoryMappings">
+    <mapping directory="" vcs="Git" />
+  </component>
+</project>
\ No newline at end of file
Index: .idea/.idea.LIN.Communication/.idea/encodings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.LIN.Communication/.idea/encodings.xml b/.idea/.idea.LIN.Communication/.idea/encodings.xml
new file mode 100644
--- /dev/null	(date 1695907101097)
+++ b/.idea/.idea.LIN.Communication/.idea/encodings.xml	(date 1695907101097)
@@ -0,0 +1,4 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project version="4">
+  <component name="Encoding" addBOMForNewFiles="with BOM under Windows, with no BOM otherwise" />
+</project>
\ No newline at end of file
Index: .idea/.idea.LIN.Communication/.idea/.gitignore
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/.idea.LIN.Communication/.idea/.gitignore b/.idea/.idea.LIN.Communication/.idea/.gitignore
new file mode 100644
--- /dev/null	(date 1695907110083)
+++ b/.idea/.idea.LIN.Communication/.idea/.gitignore	(date 1695907110083)
@@ -0,0 +1,13 @@
+# Default ignored files
+/shelf/
+/workspace.xml
+# Rider ignored files
+/modules.xml
+/contentModel.xml
+/.idea.LIN.Communication.iml
+/projectSettingsUpdater.xml
+# Editor-based HTTP Client requests
+/httpRequests/
+# Datasource local storage ignored files
+/dataSources/
+/dataSources.local.xml
Index: LIN.Communication/Data/Profiles.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>namespace LIN.Communication.Data;\r\n\r\n\r\npublic class Profiles\r\n{\r\n\r\n\r\n\r\n    #region Abstracciones\r\n\r\n\r\n    /// <summary>\r\n    /// Crea un perfil.\r\n    /// </summary>\r\n    /// <param name=\"data\">Modelo.</param>\r\n    public async static Task<ReadOneResponse<ProfileModel>> Create(AuthModel<ProfileModel> data)\r\n    {\r\n\r\n        // Contexto\r\n        (Conexi√≥n context, string connectionKey) = Conexi√≥n.GetOneConnection();\r\n\r\n        // respuesta\r\n        var response = await Create(data, context);\r\n\r\n        context.CloseActions(connectionKey);\r\n\r\n        return response;\r\n\r\n    }\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Obtiene un perfil\r\n    /// </summary>\r\n    /// <param name=\"id\">ID del perfil</param>\r\n    public async static Task<ReadOneResponse<ProfileModel>> Read(int id)\r\n    {\r\n\r\n        // Contexto\r\n        (Conexi√≥n context, string connectionKey) = Conexi√≥n.GetOneConnection();\r\n\r\n        // respuesta\r\n        var response = await Read(id, context);\r\n\r\n        context.CloseActions(connectionKey);\r\n\r\n        return response;\r\n\r\n    }\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Obtiene un perfil por medio del ID de su cuenta.\r\n    /// </summary>\r\n    /// <param name=\"id\">ID de la cuenta</param>\r\n    public async static Task<ReadOneResponse<ProfileModel>> ReadByAccount(int id)\r\n    {\r\n\r\n        // Contexto\r\n        (Conexi√≥n context, string connectionKey) = Conexi√≥n.GetOneConnection();\r\n\r\n        // respuesta\r\n        var response = await ReadByAccount(id, context);\r\n\r\n        context.CloseActions(connectionKey);\r\n\r\n        return response;\r\n\r\n    }\r\n\r\n\r\n\r\n    #endregion\r\n\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Crea un perfil.\r\n    /// </summary>\r\n    /// <param name=\"data\">Modelo.</param>\r\n    /// <param name=\"context\">Contexto de conexi√≥n.</param>\r\n    public async static Task<ReadOneResponse<ProfileModel>> Create(AuthModel<ProfileModel> data, Conexi√≥n context)\r\n    {\r\n        // ID\r\n        data.Profile.ID = 0;\r\n        data.Profile.Friends = new();\r\n\r\n        // Ejecuci√≥n\r\n        try\r\n        {\r\n            var res = context.DataBase.Profiles.Add(data.Profile);\r\n            await context.DataBase.SaveChangesAsync();\r\n            return new(Responses.Success, data.Profile);\r\n        }\r\n        catch \r\n        {\r\n        }\r\n        return new();\r\n    }\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Obtiene un perfil\r\n    /// </summary>\r\n    /// <param name=\"id\">ID del perfil</param>\r\n    /// <param name=\"context\">Contexto de conexi√≥n.</param>\r\n    public async static Task<ReadOneResponse<ProfileModel>> Read(int id, Conexi√≥n context)\r\n    {\r\n     \r\n\r\n        // Ejecuci√≥n\r\n        try\r\n        {\r\n\r\n            var profile = await (from P in context.DataBase.Profiles\r\n                                 where P.ID == id\r\n                                 select P).FirstOrDefaultAsync();\r\n\r\n            return new(Responses.Success, profile ?? new());\r\n        }\r\n        catch\r\n        {\r\n        }\r\n        return new();\r\n    }\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Obtiene un perfil por medio del ID de su cuenta.\r\n    /// </summary>\r\n    /// <param name=\"id\">ID de la cuenta</param>\r\n    /// <param name=\"context\">Contexto de conexi√≥n.</param>\r\n    public async static Task<ReadOneResponse<ProfileModel>> ReadByAccount(int id, Conexi√≥n context)\r\n    {\r\n\r\n\r\n        // Ejecuci√≥n\r\n        try\r\n        {\r\n\r\n            var profile = await (from P in context.DataBase.Profiles\r\n                                 where P.AccountID == id\r\n                                 select P).FirstOrDefaultAsync();\r\n\r\n            if (profile == null)\r\n                return new(Responses.NotExistProfile);\r\n\r\n            return new(Responses.Success, profile ?? new());\r\n        }\r\n        catch\r\n        {\r\n        }\r\n        return new();\r\n    }\r\n\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LIN.Communication/Data/Profiles.cs b/LIN.Communication/Data/Profiles.cs
--- a/LIN.Communication/Data/Profiles.cs	(revision 4862f6d6b8acc1ddc3f69c239cd7d7c2f3bd0bcf)
+++ b/LIN.Communication/Data/Profiles.cs	(date 1695908804702)
@@ -71,6 +71,36 @@
     }
 
 
+  
+    public async static Task<ResponseBase> SetLastConnection(int id, DateTime time)
+    {
+
+        // Contexto
+        (Conexi√≥n context, string connectionKey) = Conexi√≥n.GetOneConnection();
+
+        // respuesta
+        var response = await SetLastConnection(id, time, context);
+
+        context.CloseActions(connectionKey);
+
+        return response;
+
+    }
+    
+    public async static Task<ReadOneResponse<DateTime>> GetLastConnection(int id)
+    {
+
+        // Contexto
+        (Conexi√≥n context, string connectionKey) = Conexi√≥n.GetOneConnection();
+
+        // respuesta
+        var response = await GetLastConnection(id, context);
+
+        context.CloseActions(connectionKey);
+
+        return response;
+
+    }
 
     #endregion
 
@@ -157,6 +187,62 @@
         }
         return new();
     }
+    
+    
+    
+  
+    public async static Task<ResponseBase> SetLastConnection(int id, DateTime time, Conexi√≥n context)
+    {
+
+
+        // Ejecuci√≥n
+        try
+        {
+
+            var profile = await (from P in context.DataBase.Profiles
+                where P.ID == id
+                select P).Select(T=>new ProfileModel()
+            {
+                ID = T.ID
+            }).FirstOrDefaultAsync();
+
+            if (profile == null)
+                return new(Responses.NotExistProfile);
+
+            profile.LastConnection = time;
+            context.DataBase.SaveChanges();
+            
+            return new(Responses.Success);
+        }
+        catch
+        {
+        }
+        return new();
+    }
+
+    
+    
+    public async static Task<ReadOneResponse<DateTime>> GetLastConnection(int id, Conexi√≥n context)
+    {
+
+        // Ejecuci√≥n
+        try
+        {
+
+            var actual = DateTime.Now.AddDays(-7);
+
+            var profile = await (from P in context.DataBase.Profiles
+                where P.ID == id
+                && P.LastConnection > actual
+                select P).Select(T=>T.LastConnection).FirstOrDefaultAsync();
+
+            return new(Responses.Success, profile);
+        }
+        catch
+        {
+        }
+        return new();
+    }
 
 
 
Index: LIN.Communication/Hubs/ChatHub.cs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>namespace LIN.Communication.Hubs;\r\n\r\n\r\npublic class ChatHub : Hub\r\n{\r\n\r\n\r\n    public class Proff\r\n    {\r\n        public ProfileModel Profile { get; set; }\r\n        public List<string> Devices { get; set; }\r\n        public DateTime LastTime { get; set; }\r\n    }\r\n\r\n\r\n    /// <summary>\r\n    /// Lista perfiles.\r\n    /// </summary>\r\n    public static readonly Dictionary<int, Proff> Profiles = new();\r\n\r\n\r\n\r\n\r\n\r\n\r\n    public override async Task OnDisconnectedAsync(Exception? exception)\r\n    {\r\n        try\r\n        {\r\n\r\n            var count = Profiles.Where(T => T.Value.Devices.Contains(this.Context.ConnectionId)).FirstOrDefault();\r\n\r\n            count.Value.LastTime = DateTime.Now;\r\n\r\n            count.Value.Devices.Remove(this.Context.ConnectionId);\r\n        }\r\n        catch\r\n        {\r\n        }\r\n    }\r\n\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Agrega a el grupo\r\n    /// </summary>\r\n    public void Load(ProfileModel profile)\r\n    {\r\n        try\r\n        {\r\n\r\n            Proff proff = new Proff();\r\n\r\n            var exist = Profiles.Where(T => T.Key == profile.ID).FirstOrDefault();\r\n            if (exist.Key == 0)\r\n            {\r\n                proff = new Proff()\r\n                {\r\n                    Profile = profile,\r\n                    Devices = new List<string>()\r\n                };\r\n\r\n                Profiles.Add(profile.ID, proff\r\n               );\r\n            }\r\n            else\r\n            {\r\n                proff = exist.Value;\r\n            }\r\n\r\n            proff.Devices.Add(this.Context.ConnectionId);\r\n\r\n        }\r\n        catch\r\n        {\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Une una conexi√≥n a un grupo de tiempo real.\r\n    /// </summary>\r\n    /// <param name=\"name\">ID del grupo</param>\r\n    public async Task JoinGroup(int name)\r\n    {\r\n        await Groups.AddToGroupAsync(Context.ConnectionId, name.ToString());\r\n    }\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Elimina un usuario de un grupo.\r\n    /// </summary>\r\n    /// <param name=\"name\">ID del grupo</param>\r\n    public async Task LeaveGroup(string name)\r\n    {\r\n        await Groups.RemoveFromGroupAsync(Context.ConnectionId, name);\r\n    }\r\n\r\n\r\n\r\n    /// <summary>\r\n    /// Enviar un mensaje.\r\n    /// </summary>\r\n    /// <param name=\"me\">ID del perfil</param>\r\n    /// <param name=\"groupName\">ID del grupo</param>\r\n    /// <param name=\"message\">Mensaje</param>\r\n    public async Task SendMessage(int me, int groupName, string message)\r\n    {\r\n\r\n        // Si el mansaje esta vac√≠o.\r\n        if (message.Trim() == string.Empty)\r\n            return;\r\n\r\n        // Obtiene el perfil.\r\n        ProfileModel? profile = Profiles.Where(P => P.Key == me).FirstOrDefault().Value?.Profile;\r\n\r\n        // Si el perfil no existe, o esta registrado.\r\n        if (profile == null)\r\n            return;\r\n\r\n        // Modelo del mensaje.\r\n        MessageModel messageModel = new()\r\n        {\r\n            Contenido = message,\r\n            Remitente = profile,\r\n            Time = DateTime.Now,\r\n            Conversacion = new()\r\n            {\r\n                ID = groupName\r\n            }\r\n        };\r\n\r\n        // Env√≠a el mensaje en tiempo real.\r\n        await Clients.Group(groupName.ToString()).SendAsync($\"sendMessage\", messageModel);\r\n\r\n        // Establece el ID de la conversaci√≥n\r\n\r\n\r\n        // Crea el mensaje en la BD\r\n        await Data.Messages.Create(messageModel);\r\n\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/LIN.Communication/Hubs/ChatHub.cs b/LIN.Communication/Hubs/ChatHub.cs
--- a/LIN.Communication/Hubs/ChatHub.cs	(revision 4862f6d6b8acc1ddc3f69c239cd7d7c2f3bd0bcf)
+++ b/LIN.Communication/Hubs/ChatHub.cs	(date 1695907639548)
@@ -32,6 +32,8 @@
 
             count.Value.LastTime = DateTime.Now;
 
+            _=Data.Profiles.SetLastConnection(count.Key, count.Value.LastTime);
+
             count.Value.Devices.Remove(this.Context.ConnectionId);
         }
         catch
